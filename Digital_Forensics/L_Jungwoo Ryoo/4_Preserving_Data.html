<!DOCTYPE html>
<html lang="en">
    <head>

    </head>
    <body>
        <h4>Evidence Perservation Approaches</h4>
        <p>The first task to be conducted at a computer crime scene is to preserve evidence. The data you collect there could be all you have in solving a criminal case or policy violation, which is why you should be extremely careful to capture everything possible. While in hurry to collect evidence it's entirely possible to make some significant mistakes like accidentally adding, deleting, or modifying data. The consequences are grave because the court may not accept the compromised digital evidence you submit. This is why we have to do our best to keep our evidence as pristine as possible, which is the primary goal of data preservation in digital forensics. Luckily, we have well established and concrete ways to preserve data. The first option is to use write blockers when copying data from a source, which could be a hard drive in your computer, USB drive, or an external data storage device. As their name suggests, write blockers prevent writing to an evidence drive. After deploying your favorite write blocker but before starting to make a copy of a data storage medium the best practice is to get a hash value. What this does is to generate a unique string that represents a specific data set, like a partition. Once you get a copy of the partition, you can produce another hash value. If the hash values don't match the source and its copy are not identical. Mounting and unmounting drives are also relevant to data preservation, especially in Linux and Unix operating systems. Mounting is a mechanism an operating system, or OS, uses to make a drive or partition visible. If the OS doesn't recognize a data source, it cannot do anything to it, which is why we always want to begin with a drive unmounted before starting our forensic work. With data preservation techniques, such as write blockers, hashing, and unmounting there is much less chance for mishaps. They also ensure that your evidence collection process is sound and valid.</p>
        <h4>Using a Software Write Blockers</h4>
        <p>In computer forensics, preserving data integrity, or preserving data itself is one of our top priorities. In this lesson, we'll be exploring the role of write blockers, and preserving data integrity in computer forensics situations. Computer forensics rule number one is to not damage your evidence. In this case, the evidence refers to your evidence drive. The risk you're always running into is your operating system writing to your evidence drive. One of the countermeasures to keep this from happening is using a write blocker. There are primarily two different types of write blockers. The first type is hardware write blockers. Usually, these devices sit between an evidence drive and a forensic workstation. The second type is a software write blocker, and sometimes it's built into a computer forensics suite, like EnCase or FTK. You could also accomplish the same write-blocking effect by changing the configuration of your operating system. This is what a hardware write blocker looks like. In addition to write blocking, there are also some other factors to consider to protect the viability of your evidence. Physical security or chain of custody is one of them. By taking care of it, you know who had access to the physical evidence drive, when, and why. You can record all this information in a chain of custody form. Let's say that the process of making an image of an evidence drive, including the use of a write blocker, went flawlessly. If your evidence drive still turns out to be compromised, now you know that it happened through unauthorized physical access. This is why we'll provide you with plenty of opportunities to use various types of write blockers, as well as other means of securing and ensuring the integrity of your evidence drive.</p>
        <h4>Using Hardwire Write Blockers</h4>
        <p>Hardware write blockers come in many different forms. Let's look at some popular solutions. The most basic solution or poor man's version is to simply connect an evidence drive through a USB interface. Here you rely on software for write blocking. In this case, all the hardware does is simply providing a physical interface between your evidence drive and your computer forensics workstation. Take a look at this picture you can see that there is a USB cable connected to the forensics workstation and a SATA cable to the evidence drive. A slightly more advanced solution is a hard drive docking station. The biggest advantage here is the cleaner form factor. There are less cables to mess with. But the docking station approach also requires software to do the actual write blocking. Professionals deserve more sophisticated solutions. The primary goal here is to physically block writing and avoid accidents to comply with legal standards and requirements. Let's say that your conducting an investigation and in the middle of it something goes wrong with your hardware write blocker and that's the last thing you want. These professional grade hardware write blockers are more expensive but they provide iron clad operations. There are some well known manufacturers of hardware write blockers such as WiebeTech by CRU. This company is a manufacturer of many other types of computer forensics equipment too. One of the main features of WiebeTech write blockers is more interface options. This particular product featured here provides Firewire USB 3.0 External Serial ATA etcetera. It also comes with more convenient features like switches and digital displays. The most advanced hardware write blocking option is hard drive duplicators. They're fast and they're mostly plug and play. All you have to do is plug in your hard drive and then the rest will be taken care of by the duplicator. Therefore, it provides a mostly automated solution. When you're trying to buy a hardware write blocker the purchasing decision has to be based on the purpose and the nature of your investigation. You don't always need the most expensive equipment out there. Here, the key is that you are making an informed decision.</p>
        <h4>Hashing</h4>
        <p>Hashing plays an important role in computer forensics. It ensures that a copy of data you're making is remaining identical to its source. Hashing refers to the process of transforming an input which is usually a file into an output which is a unique string associated with that file. There are some important characteristics about hashing. Any slight changes you're making in a file will get amplified in huge changes in its hash value. This makes it very easy to detect changes made to a file either by accident or on purpose. Hashing ensures data integrity which means that no unintended changes are made in the data. In the context of computer forensics, this means the evidence drive remains the same during your investigation. That is a forensic image or copy of the evidence drive stays the same. Therefore hashing is an essential part of your computer forensics investigation. Any non-trivial computer forensics tools should come equipped with an ability to produce hash values. Now we'll do a quick demo of hashing on a Linux operating system. First, let's create a text file called test.txt by typing nano test.txt. Notice that there is a space between nano and the file name test.txt. Nano is one of the text editors you can use on a Linux operating system. Now press Enter. And type a sentence. Now to save this file, simple press Control and X together and then type Y to save the file. Since you're going to be accepting the file name as test.txt, all we have to do is press Enter here. Now the next step is to use one of the built-in hash algorithms of your Linux operating system which is called md5sum. Type md5sum and then the name of the file which is test.txt. And press Enter. You see the hash value of the file, test.txt right here. Now let's make some changes in the original file, test.txt. To edit the file again, type nano text.txt. This time we'll just add one word. Not. So, the sentence now reads as this is not a test! Now save the file by pressing Control and X key together again. Type Y, accept the file name as is and press Enter. Now we'll run the ash algorithm again by typing md5sum space test.txt, this time just use an up arrow key to recall your command, md5sum space test.txt and press Enter. You can see the two hash values generated side by side and you can also see that they're radically different because you made a change in the file test.txt. What if you changed the file name but without really changing the content? Do you think the hash value will change again? Now you can go ahead and try this and see what happens. Hashing is used in many places in digital forensics. Now you understand its concept and practical application which takes you one step closer to becoming a competent digital forensics investigator.</p>
        <h4>Hash Algorithms</h4>
        <p>There are various implementations of hash algorithms. One of the well-known hash algorithms is MD5, that is still popular in digital forensics. However, it's proven to be vulnerable. There is another algorithm called Secure Hash Algorithm, or SHA, which is a more secure version of MD5. There is SHA-1, SHA-2, and SHA-3. These are just different variations of SHA. Collision is a known vulnerability in hash algorithms. It occurs when two different files produce the same hash value when put through the same algorithm. As you can see in this diagram, File 1 and File 2 are different, but when they go through the same hash algorithm, sometimes it's possible that you could end up with the same hash value. This almost never happens, but theoretically speaking, this could occur. Collisions have been found in both MD5 and SHA. A way to make a hash algorithm less vulnerable is to increase the size of its output. The bigger the hash value, the less the possibility of a collision. That is, a bigger hash value means stronger and more secure hashing.</p>
        <h4>Understanding Mounting</h4>
        <p>Mounting is a concept related to partitioning. We already learned about partitioning in another lesson. Mounting is the process of making a partition visible to an operating system, or OS, and eventually to an end user, especially on a Linux OS. Unmounting is the opposite. Connecting the drive and making it available to an OS can be dangerous, because your OS can write to it. Another concept related to mounting is that of a mount point. It is simply a directory where a partition is made visible after mounting is done. Let's do a quick demo of mounting here. I already have my USB drive plugged into my computer. Now, as soon as you plug in your USB drive, you'll see an icon like this. Now, what this means is that your OS picked up your USB drive. This is probably the last thing you want in your computer forensics workstation, because your OS could have written to your USB drive, which could be your evidence drive. This happened because the OS you are using is not a forensic copy, it's a regular copy of Ubuntu OS. In a forensic copy, the OS won't automatically mount a USB drive like this. Therefore, we'll start by unmounting our USB drive. To unmount a USB drive, simply type umount and then the name of the partition. But in this case, we don't know what the name of the partition is on the USB drive. To know the partition name, we need another command, which is fdisk. Type sudo fdisk option -l. You cannot run your fdisk command directly because it requires administrator privilege to run. So that's why we type in sudo in front. This is equivalent to run as administrator on a Windows OS. We also need a command to trim the output of the fdisk command to only show what we are interested in. This is why I use pipe space, grep -i dev, which will display only the lines containing the string dev. Now, I'll press Enter. We see all the storage devices connected to our computer and partitions on them. The storage device we're interested in is our USB drive. In this case, the USB drive and its partition are showing up as /dev/sdb1. This is the name to use to unmount the USB drive. I know that it's sdb because sda is the first disk drive letter referring to a hard drive, and I also know that there's only one hard drive attached to my machine. The next drive letter is supposed to be sdb, which is my USB drive. Now we're ready, type sudo umount. Note that it's not unmount, but umount. And then the name of the partition, which is /dev/sdb1. Pay attention to the naming convention here, dev/sdb refers the entire physical drive. When we're referring to the individual partitions on the same physical drive, we're using a numbering system such as one, two and three, as we could have more than one partition on a physical drive. In this case we're dealing with one partition, which is why we have a number one next to the drive name sdb. Now, press Enter, and as soon as you do that, you can see that the USB drive icon is now gone, and the drive is invisible to the operating system. We just learned how to unmount a partition, and this is very significant in your computer forensics investigation, because a lot of times, in your investigations, you want your storage device to stay unmounted.</p>
        <h4>Mounting Manually</h4>
        <p> in a forensic copy of your Linux OS, a storage device connected to your machine is not mounted by default. In case you're not dealing with an evidence drive and you simply want to mount the drive, here is how you do it. First identify the drive and the partition you want to mount. From our lesson earlier, we know the partition is /dev/sdb1. To mount it, first of all, we need to create a mount point. A mount point is a directory where you would like to see the content of a drive. Create a new directory by typing mkdir space and then the name of your mount point and we'll call it usb_mounted. Press Enter. Do ls to see what's in the current directory, as you can see, now we have a new directory created called usb_mounted. Let's see what's inside the newly created directory. Type cd space and the name of the mount point, usb_mounted. Press Enter. Do another ls, press Enter. As you see, there is nothing in the mount point directory we just created. Let's go back to the parent directory, type cd space and two dots. Cd here means change directory. The two dots signify the parent directory, so change your directory to the parent directory. We're going back to where we started. Press Enter, type ls again. Now we are ready to mount our partition. The command is sudo space mount space file format type option -t space vfat and then the name of the partition which is /dev/sdb1 and space, the name of the mount point. The directory was ./usb_mounted. The dot in front of the forward slash symbol means the current directory. Now press Enter. If you don't get any error messages, the partition has been successfully mounted. Let's see if it works. To check if the partition has been mounted successfully, we have to go to the mount point. Let's do change directory to the mount point which is cd space usb_mounted. Press Enter. Type ls. Now you see the files and the folders on the partition because the partition has been successfully mounted. As a computer forensics investigator, it's nice to have a way to control when a drive is mounted and unmounted.</p>




    </body>
</html>